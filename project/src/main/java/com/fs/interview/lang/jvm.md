# GC

## 内存分布
JVM内存结构主要有三大块：
堆内存
方法区:各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量

栈。

程序计数器、虚拟机栈、本地方法栈



堆内存是JVM中最大的一块由年轻代和老年代组成，
而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配

Survivor区存在的意义是避免新生代的太快进入到老年代



https://www.cnblogs.com/ityouknow/p/5610232.html


## 垃圾回收算法

### 标记清除

首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。

它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，
当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。


### 复制

“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，
运行高效。

只是这种算法的代价是将内存缩小为原来的一半；持续复制长生存期的对象则导致效率降低，不适合老年代。

### 标记压缩
在标记算法基础上，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存


## 垃圾收集器

CMS收集器

初始标记（CMS initial mark）、并发标记（CMS concurrent mark）、重新标记（CMS remark）、并发清除（CMS concurrent sweep）

优点:并发收集、低停顿 

缺点：产生大量空间碎片、并发阶段会降低吞吐量

G1收集器

1. 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。

2. 可预测停顿，这是G1的另一大优势